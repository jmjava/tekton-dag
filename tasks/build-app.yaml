apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: build-stack-apps
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/part-of: tekton-job-standardization
spec:
  description: >
    Two-phase build for every app in the stack:
      1. select-tool-apps — writes per-tool app lists to .tool-apps.json
      2. compile — one step per tool (npm, maven, gradle, pip, composer), each with its own image when provided
      3. containerize — runs Kaniko to build and push the Docker image
    When compile-image-* params are set, those steps use pre-baked images (e.g. tekton-dag-build-*).
    When unset (default ubuntu:22.04), the step installs that tool at runtime. If an app has no build
    config or tool=none, only the Kaniko step runs (Dockerfile-only build).
  params:
    - name: stack-json
      type: string
      description: "Full stack graph JSON from resolve-stack"
    - name: build-apps
      type: string
      description: "Space-separated list of app names to build"
    - name: image-registry
      type: string
      description: "Container registry base URL"
    - name: image-tag
      type: string
      description: "Tag to apply to built images"
    - name: tag-prefix
      type: string
      default: "pr-"
      description: "Prefix for image tag (pr- for PR builds, v for releases, empty for merge)"
    - name: compile-image-npm
      type: string
      default: "ubuntu:22.04"
      description: "Image for npm compile step (default ubuntu + runtime install)"
    - name: compile-image-maven
      type: string
      default: "ubuntu:22.04"
      description: "Image for Maven compile step (JDK + Maven pre-installed when set)"
    - name: compile-image-gradle
      type: string
      default: "ubuntu:22.04"
      description: "Image for Gradle compile step (JDK pre-installed when set)"
    - name: compile-image-pip
      type: string
      default: "ubuntu:22.04"
      description: "Image for pip compile step (Python pre-installed when set)"
    - name: compile-image-php
      type: string
      default: "ubuntu:22.04"
      description: "Image for Composer/PHP compile step (PHP + Composer pre-installed when set)"
  workspaces:
    - name: source
    - name: build-cache
      optional: true
      description: "Persistent volume for dependency caches (.m2, .npm, .gradle, .pip, .composer). Survives across runs."
  results:
    - name: built-images
      description: "JSON map of app-name → full image URI"

  steps:
    # ----------------------------------------------------------------
    # Step 1: Select which apps use which build tool (writes .tool-apps.json)
    # ----------------------------------------------------------------
    - name: select-tool-apps
      image: alpine:3.19
      workingDir: $(workspaces.source.path)
      env:
        - name: STACK_JSON
          value: $(params.stack-json)
        - name: BUILD_APPS
          value: $(params.build-apps)
      script: |
        #!/bin/sh
        set -e
        apk add --no-cache jq >/dev/null 2>&1
        NPM_APPS=""; MAVEN_APPS=""; GRADLE_APPS=""; PIP_APPS=""; COMPOSER_APPS=""
        for app in $BUILD_APPS; do
          tool=$(echo "$STACK_JSON" | jq -r --arg a "$app" '.apps[]|select(.name==$a)|.build.tool // "none"')
          case "$tool" in
            npm) NPM_APPS="$NPM_APPS $app" ;;
            maven) MAVEN_APPS="$MAVEN_APPS $app" ;;
            gradle) GRADLE_APPS="$GRADLE_APPS $app" ;;
            pip) PIP_APPS="$PIP_APPS $app" ;;
            composer) COMPOSER_APPS="$COMPOSER_APPS $app" ;;
          esac
        done
        jq -n \
          --arg n "${NPM_APPS# }" --arg m "${MAVEN_APPS# }" --arg g "${GRADLE_APPS# }" --arg p "${PIP_APPS# }" --arg c "${COMPOSER_APPS# }" \
          '{npm:(if $n=="" then [] else ($n|split(" ")|map(select(length>0))) end),maven:(if $m=="" then [] else ($m|split(" ")|map(select(length>0))) end),gradle:(if $g=="" then [] else ($g|split(" ")|map(select(length>0))) end),pip:(if $p=="" then [] else ($p|split(" ")|map(select(length>0))) end),composer:(if $c=="" then [] else ($c|split(" ")|map(select(length>0))) end)}' > .tool-apps.json
        echo "Tool app lists written to .tool-apps.json"

    # ----------------------------------------------------------------
    # Compile steps (one per tool; each uses its own image when provided)
    # ----------------------------------------------------------------
    - name: compile-npm
      image: $(params.compile-image-npm)
      workingDir: $(workspaces.source.path)
      env:
        - name: STACK_JSON
          value: $(params.stack-json)
        - name: COMPILE_IMAGE
          value: $(params.compile-image-npm)
        - name: MY_TOOL
          value: npm
      script: |
        #!/usr/bin/env bash
        set -e
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then apt-get update -qq && apt-get install -y -qq curl jq ca-certificates gnupg >/dev/null 2>&1; fi
        [ "$(workspaces.build-cache.bound)" = "true" ] && CACHE="$(workspaces.build-cache.path)" && mkdir -p "$CACHE/.npm" && export npm_config_cache="$CACHE/.npm"
        APPS=$(jq -r '.npm[]' .tool-apps.json 2>/dev/null || true)
        [ -z "$APPS" ] && echo "No npm apps" && exit 0
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then
          curl -fsSL https://deb.nodesource.com/setup_22.x | bash - >/dev/null 2>&1 && apt-get install -y -qq nodejs >/dev/null 2>&1
        fi
        for APP in $APPS; do
          echo "=== Compile (npm): $APP ==="
          CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."build-command" // ""')
          PRE_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."pre-command" // ""')
          POST_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."post-command" // ""')
          CONTEXT=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|."context-dir" // "."')
          APP_DIR="$(workspaces.source.path)"; [ -d "$(workspaces.source.path)/${APP}" ] && APP_DIR="$(workspaces.source.path)/${APP}"
          [ "$CONTEXT" != "." ] && [ -d "${APP_DIR}/${CONTEXT}" ] && APP_DIR="${APP_DIR}/${CONTEXT}"
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.env // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.env[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.legacy // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.legacy[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          cd "$APP_DIR"
          [ -n "$PRE_CMD" ] && eval "$PRE_CMD"
          if [ -n "$CMD" ]; then
            RUN_CMD="$CMD"; echo "$CMD" | grep -q "npm ci" && [ ! -f package-lock.json ] && RUN_CMD=$(echo "$CMD" | sed 's/npm ci/npm install/g')
            eval "$RUN_CMD"
          else
            [ -f package-lock.json ] && npm ci || npm install; npm run build --if-present
          fi
          [ -n "$POST_CMD" ] && eval "$POST_CMD"
        done
        echo "Compile (npm) done."

    - name: compile-maven
      image: $(params.compile-image-maven)
      workingDir: $(workspaces.source.path)
      env:
        - name: STACK_JSON
          value: $(params.stack-json)
        - name: COMPILE_IMAGE
          value: $(params.compile-image-maven)
        - name: MY_TOOL
          value: maven
      script: |
        #!/usr/bin/env bash
        set -e
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then apt-get update -qq && apt-get install -y -qq curl jq ca-certificates openjdk-21-jdk-headless >/dev/null 2>&1; fi
        [ "$(workspaces.build-cache.bound)" = "true" ] && CACHE="$(workspaces.build-cache.path)" && mkdir -p "$CACHE/.m2/repository" && export MAVEN_OPTS="-Dmaven.repo.local=$CACHE/.m2/repository"
        APPS=$(jq -r '.maven[]' .tool-apps.json 2>/dev/null || true)
        [ -z "$APPS" ] && echo "No maven apps" && exit 0
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then
          apt-get install -y -qq maven >/dev/null 2>&1 || { curl -fsSL https://dlcdn.apache.org/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.tar.gz | tar xz -C /opt && ln -sf /opt/apache-maven-3.9.6/bin/mvn /usr/local/bin/mvn; }
        fi
        for APP in $APPS; do
          echo "=== Compile (maven): $APP ==="
          CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."build-command" // ""')
          PRE_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."pre-command" // ""')
          POST_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."post-command" // ""')
          CONTEXT=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|."context-dir" // "."')
          APP_DIR="$(workspaces.source.path)"; [ -d "$(workspaces.source.path)/${APP}" ] && APP_DIR="$(workspaces.source.path)/${APP}"
          [ "$CONTEXT" != "." ] && [ -d "${APP_DIR}/${CONTEXT}" ] && APP_DIR="${APP_DIR}/${CONTEXT}"
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.env // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.env[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.legacy // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.legacy[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          cd "$APP_DIR"
          [ -n "$PRE_CMD" ] && eval "$PRE_CMD"
          [ -n "$CMD" ] && eval "$CMD" || mvn -B clean package -DskipTests
          [ -n "$POST_CMD" ] && eval "$POST_CMD"
        done
        echo "Compile (maven) done."

    - name: compile-gradle
      image: $(params.compile-image-gradle)
      workingDir: $(workspaces.source.path)
      env:
        - name: STACK_JSON
          value: $(params.stack-json)
        - name: COMPILE_IMAGE
          value: $(params.compile-image-gradle)
        - name: MY_TOOL
          value: gradle
      script: |
        #!/usr/bin/env bash
        set -e
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then apt-get update -qq && apt-get install -y -qq curl jq ca-certificates openjdk-21-jdk-headless >/dev/null 2>&1; fi
        [ "$(workspaces.build-cache.bound)" = "true" ] && CACHE="$(workspaces.build-cache.path)" && mkdir -p "$CACHE/.gradle" && export GRADLE_USER_HOME="$CACHE/.gradle"
        APPS=$(jq -r '.gradle[]' .tool-apps.json 2>/dev/null || true)
        [ -z "$APPS" ] && echo "No gradle apps" && exit 0
        for APP in $APPS; do
          echo "=== Compile (gradle): $APP ==="
          RUNTIME=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.runtime // "custom"')
          CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."build-command" // ""')
          PRE_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."pre-command" // ""')
          POST_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."post-command" // ""')
          CONTEXT=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|."context-dir" // "."')
          APP_DIR="$(workspaces.source.path)"; [ -d "$(workspaces.source.path)/${APP}" ] && APP_DIR="$(workspaces.source.path)/${APP}"
          [ "$CONTEXT" != "." ] && [ -d "${APP_DIR}/${CONTEXT}" ] && APP_DIR="${APP_DIR}/${CONTEXT}"
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.env // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.env[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.legacy // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.legacy[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          cd "$APP_DIR"
          [ -n "$PRE_CMD" ] && eval "$PRE_CMD"
          if [ -n "$CMD" ]; then eval "$CMD"; else
            if [ -f gradlew ]; then chmod +x gradlew; case "$RUNTIME" in spring-boot) ./gradlew clean bootJar -x test ;; spring-legacy) ./gradlew clean war -x test ;; *) ./gradlew clean build -x test ;; esac
            else echo "WARN: No gradlew"; fi
          fi
          [ -n "$POST_CMD" ] && eval "$POST_CMD"
        done
        echo "Compile (gradle) done."

    - name: compile-pip
      image: $(params.compile-image-pip)
      workingDir: $(workspaces.source.path)
      env:
        - name: STACK_JSON
          value: $(params.stack-json)
        - name: COMPILE_IMAGE
          value: $(params.compile-image-pip)
        - name: MY_TOOL
          value: pip
      script: |
        #!/usr/bin/env bash
        set -e
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then apt-get update -qq && apt-get install -y -qq curl jq ca-certificates python3.12 python3.12-venv python3-pip 2>/dev/null || apt-get install -y -qq python3 python3-venv python3-pip >/dev/null 2>&1; fi
        [ "$(workspaces.build-cache.bound)" = "true" ] && CACHE="$(workspaces.build-cache.path)" && mkdir -p "$CACHE/.pip" && export PIP_CACHE_DIR="$CACHE/.pip"
        APPS=$(jq -r '.pip[]' .tool-apps.json 2>/dev/null || true)
        [ -z "$APPS" ] && echo "No pip apps" && exit 0
        for APP in $APPS; do
          echo "=== Compile (pip): $APP ==="
          CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."build-command" // ""')
          PRE_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."pre-command" // ""')
          POST_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."post-command" // ""')
          CONTEXT=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|."context-dir" // "."')
          APP_DIR="$(workspaces.source.path)"; [ -d "$(workspaces.source.path)/${APP}" ] && APP_DIR="$(workspaces.source.path)/${APP}"
          [ "$CONTEXT" != "." ] && [ -d "${APP_DIR}/${CONTEXT}" ] && APP_DIR="${APP_DIR}/${CONTEXT}"
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.env // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.env[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.legacy // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.legacy[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          cd "$APP_DIR"
          [ -n "$PRE_CMD" ] && eval "$PRE_CMD"
          if [ -n "$CMD" ]; then eval "$CMD"; elif [ -f requirements.txt ]; then pip3 install -r requirements.txt; elif [ -f setup.py ] || [ -f pyproject.toml ]; then pip3 install .; else echo "WARN: No requirements.txt/setup.py/pyproject.toml"; fi
          [ -n "$POST_CMD" ] && eval "$POST_CMD"
        done
        echo "Compile (pip) done."

    - name: compile-composer
      image: $(params.compile-image-php)
      workingDir: $(workspaces.source.path)
      env:
        - name: STACK_JSON
          value: $(params.stack-json)
        - name: COMPILE_IMAGE
          value: $(params.compile-image-php)
        - name: MY_TOOL
          value: composer
      script: |
        #!/usr/bin/env bash
        set -e
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then apt-get update -qq && apt-get install -y -qq curl jq ca-certificates software-properties-common >/dev/null 2>&1 && add-apt-repository -y ppa:ondrej/php >/dev/null 2>&1 || true && apt-get update -qq && apt-get install -y -qq php8.3-cli php8.3-mbstring php8.3-xml php8.3-curl php8.3-zip unzip 2>/dev/null || apt-get install -y -qq php-cli php-mbstring php-xml php-curl php-zip unzip >/dev/null 2>&1 && curl -fsSL https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer >/dev/null 2>&1; fi
        [ "$(workspaces.build-cache.bound)" = "true" ] && CACHE="$(workspaces.build-cache.path)" && mkdir -p "$CACHE/.composer" && export COMPOSER_CACHE_DIR="$CACHE/.composer"
        APPS=$(jq -r '.composer[]' .tool-apps.json 2>/dev/null || true)
        [ -z "$APPS" ] && echo "No composer apps" && exit 0
        for APP in $APPS; do
          echo "=== Compile (composer): $APP ==="
          CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."build-command" // ""')
          PRE_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."pre-command" // ""')
          POST_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."post-command" // ""')
          CONTEXT=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|."context-dir" // "."')
          APP_DIR="$(workspaces.source.path)"; [ -d "$(workspaces.source.path)/${APP}" ] && APP_DIR="$(workspaces.source.path)/${APP}"
          [ "$CONTEXT" != "." ] && [ -d "${APP_DIR}/${CONTEXT}" ] && APP_DIR="${APP_DIR}/${CONTEXT}"
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.env // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.env[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.legacy // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.legacy[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          cd "$APP_DIR"
          [ -n "$PRE_CMD" ] && eval "$PRE_CMD"
          [ -n "$CMD" ] && eval "$CMD" || composer install --no-dev --optimize-autoloader --no-interaction
          [ -n "$POST_CMD" ] && eval "$POST_CMD"
        done
        echo "Compile (composer) done."

    # ----------------------------------------------------------------
    # Containerize every app with Kaniko
    #
    # image-tag can be either:
    #   - A JSON map like {"demo-fe":"0.1.0-rc.4"} (PR flow — per-app RC tags)
    #   - A plain string like "abc1234" (merge flow — same tag for all, re-tagged later)
    #
    # tag-prefix is prepended: "v" for RC versions, "merge-" for merge builds.
    # ----------------------------------------------------------------
    - name: containerize
      image: gcr.io/kaniko-project/executor:debug
      workingDir: $(workspaces.source.path)
      script: |
        #!/busybox/sh
        set -e

        STACK_JSON='$(params.stack-json)'
        BUILD_APPS="$(params.build-apps)"
        REGISTRY="$(params.image-registry)"
        IMAGE_TAG='$(params.image-tag)'
        TAG_PREFIX="$(params.tag-prefix)"
        WORKSPACE="$(workspaces.source.path)"

        # In Kind, localhost:PORT is not reachable from pods; the registry
        # container is on the Docker network as kind-registry:5000.
        # Kaniko pushes to the Docker-resolvable address; deployment pulls
        # use the original REGISTRY value (mapped by containerd hosts.toml).
        PUSH_REGISTRY=$(echo "$REGISTRY" | sed 's|localhost:|kind-registry:|')

        BUILT_JSON="${WORKSPACE}/.built-images.json"
        echo '{}' > "$BUILT_JSON"

        # Detect if IMAGE_TAG is JSON (contains '{')
        IS_JSON=false
        case "$IMAGE_TAG" in
          *"{"*) IS_JSON=true ;;
        esac

        for APP in $BUILD_APPS; do
          echo ""
          echo "========================================="
          echo "  Containerize: $APP"
          echo "========================================="

          if $IS_JSON; then
            APP_VER=$(echo "$IMAGE_TAG" | sed 's/[{}" ]//g' | tr ',' '\n' | grep "^${APP}:" | cut -d: -f2)
            [ -z "$APP_VER" ] && APP_VER="latest"
            TAG="${TAG_PREFIX}${APP_VER}"
          else
            TAG="${TAG_PREFIX}${IMAGE_TAG}"
          fi

          CONTEXT="."
          DOCKERFILE="Dockerfile"

          PUSH_IMAGE="${PUSH_REGISTRY}/${APP}:${TAG}"
          PULL_IMAGE="${REGISTRY}/${APP}:${TAG}"
          echo "  Push to:    $PUSH_IMAGE"
          echo "  Pull as:    $PULL_IMAGE"

          CONTEXT_PATH="${WORKSPACE}"
          if [ -d "${WORKSPACE}/${APP}" ]; then
            CONTEXT_PATH="${WORKSPACE}/${APP}"
          fi

          FULL_CONTEXT="${CONTEXT_PATH}/${CONTEXT}"
          FULL_DOCKERFILE="${FULL_CONTEXT}/${DOCKERFILE}"

          if [ -f "${FULL_DOCKERFILE}" ]; then
            /kaniko/executor \
              --dockerfile="${FULL_DOCKERFILE}" \
              --context="${FULL_CONTEXT}" \
              --destination="${PUSH_IMAGE}" \
              --cache=false \
              --insecure \
              --insecure-pull \
              --ignore-path /product_uuid \
              --ignore-path /sys
            echo "  Built and pushed: $PUSH_IMAGE"
          else
            echo "  WARN: Dockerfile not found at ${FULL_DOCKERFILE}"
            echo "  Skipping containerize (image may already exist in registry)"
          fi

          echo "\"${APP}\": \"${PULL_IMAGE}\"" >> "${BUILT_JSON}.parts"
        done

        # Build final JSON from parts (no jq in kaniko image)
        echo '{' > "$BUILT_JSON"
        if [ -f "${BUILT_JSON}.parts" ]; then
          TOTAL=$(wc -l < "${BUILT_JSON}.parts")
          COUNT=0
          while IFS= read -r line; do
            COUNT=$((COUNT + 1))
            if [ "$COUNT" -lt "$TOTAL" ]; then
              echo "  ${line}," >> "$BUILT_JSON"
            else
              echo "  ${line}" >> "$BUILT_JSON"
            fi
          done < "${BUILT_JSON}.parts"
        fi
        echo '}' >> "$BUILT_JSON"

        cat "$BUILT_JSON" | tee $(results.built-images.path)
