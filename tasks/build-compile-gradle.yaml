apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: build-compile-gradle
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/part-of: tekton-job-standardization
spec:
  description: "Runs Gradle compile for apps in .tool-apps.json (invoked only when build-apps include gradle)."
  params:
    - name: stack-json
      type: string
    - name: compile-image-gradle
      type: string
      default: "ubuntu:22.04"
  workspaces:
    - name: source
    - name: build-cache
      optional: true
  steps:
    - name: compile-gradle
      image: $(params.compile-image-gradle)
      workingDir: $(workspaces.source.path)
      env:
        - name: STACK_JSON
          value: $(params.stack-json)
        - name: COMPILE_IMAGE
          value: $(params.compile-image-gradle)
      script: |
        #!/usr/bin/env bash
        set -e
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then apt-get update -qq && apt-get install -y -qq curl jq ca-certificates openjdk-21-jdk-headless >/dev/null 2>&1; fi
        [ "$(workspaces.build-cache.bound)" = "true" ] && CACHE="$(workspaces.build-cache.path)" && mkdir -p "$CACHE/.gradle" && export GRADLE_USER_HOME="$CACHE/.gradle"
        APPS=$(jq -r '.gradle[]' .tool-apps.json 2>/dev/null || true)
        [ -z "$APPS" ] && echo "No gradle apps" && exit 0
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then
          apt-get install -y -qq gradle >/dev/null 2>&1 || true
        fi
        for APP in $APPS; do
          echo "=== Compile (gradle): $APP ==="
          RUNTIME=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.runtime // "custom"')
          CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."build-command" // ""')
          PRE_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."pre-command" // ""')
          POST_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."post-command" // ""')
          CONTEXT=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|."context-dir" // "."')
          APP_DIR="$(workspaces.source.path)"; [ -d "$(workspaces.source.path)/${APP}" ] && APP_DIR="$(workspaces.source.path)/${APP}"
          [ "$CONTEXT" != "." ] && [ -d "${APP_DIR}/${CONTEXT}" ] && APP_DIR="${APP_DIR}/${CONTEXT}"
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.env // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.env[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.legacy // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.legacy[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          cd "$APP_DIR"
          [ -n "$PRE_CMD" ] && eval "$PRE_CMD"
          if [ -n "$CMD" ]; then eval "$CMD"; else
            if [ -f gradlew ]; then chmod +x gradlew; case "$RUNTIME" in spring-boot) ./gradlew clean bootJar -x test ;; spring-legacy) ./gradlew clean war -x test ;; *) ./gradlew clean build -x test ;; esac
            else echo "WARN: No gradlew"; fi
          fi
          [ -n "$POST_CMD" ] && eval "$POST_CMD"
        done
        echo "Compile (gradle) done."
