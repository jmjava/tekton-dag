apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: build-compile-pip
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/part-of: tekton-job-standardization
spec:
  description: "Runs pip compile for apps in .tool-apps.json (invoked only when build-apps include pip)."
  params:
    - name: stack-json
      type: string
    - name: compile-image-pip
      type: string
      default: "ubuntu:22.04"
  workspaces:
    - name: source
    - name: build-cache
      optional: true
  steps:
    - name: compile-pip
      image: $(params.compile-image-pip)
      workingDir: $(workspaces.source.path)
      env:
        - name: STACK_JSON
          value: $(params.stack-json)
        - name: COMPILE_IMAGE
          value: $(params.compile-image-pip)
      script: |
        #!/usr/bin/env bash
        set -e
        if [ "$COMPILE_IMAGE" = "ubuntu:22.04" ]; then apt-get update -qq && apt-get install -y -qq curl jq ca-certificates python3.12 python3.12-venv python3-pip 2>/dev/null || apt-get install -y -qq python3 python3-venv python3-pip >/dev/null 2>&1; fi
        [ "$(workspaces.build-cache.bound)" = "true" ] && CACHE="$(workspaces.build-cache.path)" && mkdir -p "$CACHE/.pip" && export PIP_CACHE_DIR="$CACHE/.pip"
        APPS=$(jq -r '.pip[]' .tool-apps.json 2>/dev/null || true)
        [ -z "$APPS" ] && echo "No pip apps" && exit 0
        for APP in $APPS; do
          echo "=== Compile (pip): $APP ==="
          CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."build-command" // ""')
          PRE_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."pre-command" // ""')
          POST_CMD=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build."post-command" // ""')
          CONTEXT=$(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|."context-dir" // "."')
          APP_DIR="$(workspaces.source.path)"; [ -d "$(workspaces.source.path)/${APP}" ] && APP_DIR="$(workspaces.source.path)/${APP}"
          [ "$CONTEXT" != "." ] && [ -d "${APP_DIR}/${CONTEXT}" ] && APP_DIR="${APP_DIR}/${CONTEXT}"
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.env // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.env[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          for k in $(echo "$STACK_JSON" | jq -r --arg a "$APP" '.apps[]|select(.name==$a)|.build.legacy // {} | keys[]' 2>/dev/null); do v=$(echo "$STACK_JSON" | jq -r --arg a "$APP" --arg k "$k" '.apps[]|select(.name==$a)|.build.legacy[$k] // ""'); [ -n "$k" ] && export "$k=$v"; done
          cd "$APP_DIR"
          [ -n "$PRE_CMD" ] && eval "$PRE_CMD"
          if [ -n "$CMD" ]; then eval "$CMD"; elif [ -f requirements.txt ]; then pip3 install -r requirements.txt; elif [ -f setup.py ] || [ -f pyproject.toml ]; then pip3 install .; else echo "WARN: No requirements.txt/setup.py/pyproject.toml"; fi
          [ -n "$POST_CMD" ] && eval "$POST_CMD"
        done
        echo "Compile (pip) done."
